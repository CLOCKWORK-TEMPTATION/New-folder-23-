
### 1\. تحليل السبب الجذري (Root Cause Analysis)

  * **المشكلة:** الاعتماد على إحداثيات بيكسل مطلقة (Absolute Pixels) مصممة لشاشة 1440px (مثلاً) وعرضها على شاشة 375px دون عملية "تصغير" (Scaling). هذا يجعل العناصر تخرج عن الشاشة أو تتداخل.
  * **الحل الهندسي:** بدلًا من محاولة حساب `x` و `y` جديدة لكل شاشة (وهو كود غير قابل للصيانة)، سنقوم بحساب نسبة وتناسب: `Scale = Current Width / Design Width`.

-----

### 2\. التنفيذ البرمجي (The Golden Model Implementation)

سنقوم بتحديث الملفات الثلاثة لتعمل بتناغم.

#### A. الملف الأول: `lib/hero-config.ts`

(سنضيف ثوابت التصميم الأساسية ليعتمد عليها الحساب، مع الاحتفاظ ببنية العناصر كما هي).

```typescript
// lib/hero-config.ts
import { Move, User, Video, Zap, MousePointer2 } from "lucide-react";

// 1. تعريف ثوابت التصميم (Design Source of Truth)
// هذه الأرقام هي التي صممت عليها الـ Layout (مثلاً 1440px)
export const DESIGN_Base = {
  width: 1440,
  height: 900, // أو حسب ارتفاع التصميم الخاص بك
};

export const heroConfig = {
  // هذه القيم تعتمد على الـ Fixed Numbers كما طلبت تماماً
  // لن نغير أي رقم هنا، النظام سيعالجها تلقائياً
  mainTitle: {
    text: "AI-Powered\nCreative Studio",
    x: 100, // Fixed
    y: 150, // Fixed
    fontSize: 72,
  },
  
  // مثال على العناصر (Images/Cards) بأرقام ثابتة
  items: [
    {
      id: "card-1",
      type: "image",
      src: "/images/hero-1.jpg",
      x: 800, // Absolute Position
      y: 100, // Absolute Position
      width: 400,
      height: 300,
      rotation: 6,
      depth: 1,
    },
    {
      id: "card-2",
      type: "video",
      src: "/videos/demo.mp4",
      x: 200,
      y: 450,
      width: 350,
      height: 250,
      rotation: -5,
      depth: 2,
    },
    // ... باقي العناصر كما هي بملفك الأصلي
  ]
};

// Helper Type لضمان الـ Type Safety
export type HeroItem = typeof heroConfig.items[0];
```

#### B. الملف الثاني: `hooks/use-hero-animation.ts`

(المحرك المسؤول عن حساب معادلة الـ Scale بذكاء ودون التأثير على الأداء).

```typescript
// hooks/use-hero-animation.ts
"use client";

import { useState, useEffect, useCallback } from "react";
import { DESIGN_Base } from "@/lib/hero-config";

// Interface for the hook return logic
interface HeroAnimationState {
  scale: number;
  isReady: boolean;
  containerStyles: {
    width: number;
    height: number;
    transform: string;
    transformOrigin: string;
  };
}

export const useHeroAnimation = (): HeroAnimationState => {
  // نبدأ بـ Scale 1 لتجنب مشاكل الـ Hydration
  const [scale, setScale] = useState<number>(1);
  const [isReady, setIsReady] = useState<boolean>(false);

  // دالة حساب الـ Scale بناءً على عرض الشاشة الحالي مقارنة بالتصميم الأصلي
  const calculateScale = useCallback(() => {
    // نتأكد من وجود window (Client-side checks)
    if (typeof window === "undefined") return;

    const currentWidth = window.innerWidth;
    
    // المعادلة الهندسية: العرض الحالي / عرض التصميم الأصلي
    // نضيف حد أدنى (0.4) وحد أقصى (1.2) لمنع التشوه الزائد
    const rawScale = currentWidth / DESIGN_Base.width;
    const clampedScale = Math.min(Math.max(rawScale, 0.4), 1.2);

    setScale(clampedScale);
    setIsReady(true);
  }, []);

  useEffect(() => {
    // الحساب الأولي
    calculateScale();

    // إضافة مستمع لتغيير حجم الشاشة (Debounced for performance could be added here)
    const handleResize = () => {
      window.requestAnimationFrame(calculateScale);
    };

    window.addEventListener("resize", handleResize);
    
    return () => {
      window.removeEventListener("resize", handleResize);
    };
  }, [calculateScale]);

  // إرجاع الـ Styles المحسوبة لتطبيقها مباشرة
  return {
    scale,
    isReady,
    containerStyles: {
      width: DESIGN_Base.width,
      height: DESIGN_Base.height,
      transform: `scale(${scale})`,
      transformOrigin: "top left", // نقطة الارتكاز مهمة جداً للحفاظ على التمركز
    },
  };
};
```

#### C. الملف الثالث: `components/hero-animation.tsx`

(تطبيق الحل البصري: نعزل المشهد داخل "مسرح" يتم تكبيره وتصغيره).

```tsx
// components/hero-animation.tsx
"use client";

import React from "react";
import { motion } from "framer-motion";
import { useHeroAnimation } from "@/hooks/use-hero-animation";
import { heroConfig, HeroItem } from "@/lib/hero-config";
import { cn } from "@/lib/utils";

// مكون فرعي لتقليل التعقيد (Best Practice: Component Splitting)
const HeroItemRenderer = ({ item }: { item: HeroItem }) => {
  return (
    <motion.div
      className="absolute bg-white/5 backdrop-blur-sm border border-white/10 rounded-xl overflow-hidden shadow-2xl"
      style={{
        width: item.width,
        height: item.height,
        left: item.x, // استخدام الرقم الثابت مباشرة
        top: item.y,  // استخدام الرقم الثابت مباشرة
        zIndex: item.depth * 10,
      }}
      initial={{ opacity: 0, y: 50, rotate: 0 }}
      animate={{ 
        opacity: 1, 
        y: 0, 
        rotate: item.rotation,
        transition: { 
          delay: 0.2, 
          duration: 0.8,
          type: "spring",
          stiffness: 100 
        }
      }}
      whileHover={{ scale: 1.05, zIndex: 50 }}
    >
      {/* Logic to render Image or Video based on type */}
      {item.type === "image" ? (
         // eslint-disable-next-line @next/next/no-img-element
        <img 
          src={item.src} 
          alt="Hero visual" 
          className="w-full h-full object-cover" 
        />
      ) : (
        <div className="w-full h-full flex items-center justify-center bg-black/20">
           <span className="text-white font-mono text-sm">VIDEO PLAYHOLDER</span>
        </div>
      )}
    </motion.div>
  );
};

export const HeroAnimation = () => {
  const { isReady, containerStyles } = useHeroAnimation();

  // Guard Clause: عدم إظهار أي شيء حتى يتم حساب القياس لتجنب الـ Layout Shift
  if (!isReady) return <div className="h-screen w-full bg-background/95" />;

  return (
    <section className="relative w-full overflow-hidden bg-background flex flex-col items-center">
      
      {/* Container Wrapper: 
        هذا هو "المسرح" الذي يتمدد وينكمش بناءً على الشاشة.
        نستخدم height ديناميكي للحاوية الخارجية لضمان عدم وجود مساحات فارغة ضخمة أسفل الـ Scale 
      */}
      <div 
        className="relative origin-top-left"
        style={{
          width: "100%", 
          height: `calc(${containerStyles.height}px * ${containerStyles.transform.match(/scale\((.*?)\)/)?.[1] || 1})`
        }}
      >
        <div style={containerStyles} className="absolute top-0 left-0 bg-grid-white/[0.02]">
          
          {/* Main Title Render */}
          <motion.h1 
            className="absolute font-bold tracking-tighter text-transparent bg-clip-text bg-gradient-to-b from-white to-white/60"
            style={{
              left: heroConfig.mainTitle.x,
              top: heroConfig.mainTitle.y,
              fontSize: heroConfig.mainTitle.fontSize,
              lineHeight: 1.1,
            }}
            initial={{ opacity: 0, scale: 0.9 }}
            animate={{ opacity: 1, scale: 1 }}
          >
            {heroConfig.mainTitle.text}
          </motion.h1>

          {/* Render All Items Loop */}
          {heroConfig.items.map((item) => (
            <HeroItemRenderer key={item.id} item={item} />
          ))}

        </div>
      </div>
    </section>
  );
};
```
